#include "codegen_proto.h"
#include <ostream>
#include <sstream>

struct proto_state {
    std::stringstream out;
    const codegen_config& config;

    proto_state(const codegen_config& conf) : config(conf) {}
};

static void generate_proto_type(proto_state& state, ast::node* type);

static void check_config_proto(proto_state& state, const std::string& type_name, const std::string& fallback) {
    auto it = state.config.datatypes.find(type_name);
    if (it != state.config.datatypes.end()) {
        state.out << it->second.out;
    } else {
        state.out << fallback;
    }
}

static void generate_proto_object_body(proto_state& state, ast::object* obj) {
    state.out << "{\n";
    int tag = 1;
    for (auto* m : obj->named_members) {
        state.out << "    ";
        if (m->is_optional) state.out << "optional ";
        else if (dynamic_cast<ast::array*>(m->type)) state.out << "repeated ";

        ast::node* inner_type = m->type;
        if (auto* arr = dynamic_cast<ast::array*>(m->type)) inner_type = arr->type;

        generate_proto_type(state, inner_type);
        state.out << " " << m->name << " = " << tag++ << ";\n";
    }
    state.out << "}\n";
}

static void generate_proto_type(proto_state& state, ast::node* type) {
    if (!type) { check_config_proto(state, "any", "google.protobuf.Any"); return; }

    if (auto* mod = dynamic_cast<ast::module*>(type)) {
        state.out << "package " << mod->name << ";\n\n";
        for (auto* child : mod->children) generate_proto_type(state, child);
    } else if (auto* imp = dynamic_cast<ast::import_stmt*>(type)) {
        state.out << "import \"" << imp->module_name << ".proto\";\n\n";
    } else if (auto* iface = dynamic_cast<ast::interface*>(type)) {
        state.out << "message " << iface->name << " ";
        if (iface->definition) generate_proto_object_body(state, iface->definition);
        else state.out << "{}\n";
        state.out << "\n";
    } else if (auto* en = dynamic_cast<ast::enumeration*>(type)) {
        state.out << "enum " << en->name << " {\n";
        int tag = 0;
        for (const auto& member : en->members) {
            state.out << "    " << member.name << " = " << tag++ << ";\n";
        }
        state.out << "}\n\n";
    } else if (auto* alias = dynamic_cast<ast::type_alias*>(type)) {
        if (auto* obj = dynamic_cast<ast::object*>(alias->target_type)) {
            state.out << "message " << alias->name << " ";
            generate_proto_object_body(state, obj);
            state.out << "\n";
        } else {
            // Unhandled natively in proto without struct wrapper
        }
    } else if (auto* f = dynamic_cast<ast::fundamental_type_reference*>(type)) {
        switch (f->type) {
        case ast::fundamental_type::any: check_config_proto(state, "any", "google.protobuf.Any"); break;
        case ast::fundamental_type::boolean: check_config_proto(state, "boolean", "bool"); break;
        case ast::fundamental_type::number: check_config_proto(state, "number", "double"); break;
        case ast::fundamental_type::string: check_config_proto(state, "string", "string"); break;
        case ast::fundamental_type::unknown: check_config_proto(state, "unknown", "google.protobuf.Any"); break;
        case ast::fundamental_type::never: check_config_proto(state, "never", "google.protobuf.Any"); break;
        }
    } else if (auto* ref = dynamic_cast<ast::interface_reference*>(type)) {
        check_config_proto(state, ref->name, ref->name);
    } else if (auto* arr = dynamic_cast<ast::array*>(type)) {
        // Repeated arrays handled dynamically inside object members, or just array wrapper
        generate_proto_type(state, arr->type);
    } else if (auto* gref = dynamic_cast<ast::generic_type_reference*>(type)) {
        if (gref->name == "Array" || gref->name == "ReadonlyArray") {
            if (!gref->arguments.empty()) generate_proto_type(state, gref->arguments[0]);
            else state.out << "google.protobuf.Any";
        } else {
            check_config_proto(state, gref->name, gref->name);
        }
    } else {
        state.out << "/* unmapped */";
    }
}

void generate_proto(std::ostream& out, ast::file* file, const codegen_config& config) {
    proto_state state(config);
    out << "// Auto-generated by ts-type-conv\n";
    out << "syntax = \"proto3\";\n\n";

    for (auto* child : file->children) {
        generate_proto_type(state, child);
    }

    out << state.out.str();
}
